#!/usr/bin/python
# -*- coding: UTF-8 -*-

# 击鼓传花：每次只能传给左右两边，求能回到当前这个人的次数
# 思考这类问题的时候考虑从上一个状态到下一个状态之间的关系，就可以找到变量和不变量之间的关系，就可以找到递归方程，然后在找到递归出口


# 猿辅导笔试
# 题目描述
# 学校联欢晚会的时候，为了使每一个同学都能参与进来，主持人常常会带着同学们玩击鼓传花的游戏。游戏规则是这样的：n个同学坐着围成一个圆圈，指定一个同学手里拿着一束花，主持人在旁边背对着大家开始击鼓，鼓声开始之后拿着花的同学开始传花，每个同学都可以把花传给自己左右的两个同学中的一个（左右任意），当主持人停止击鼓时，传花停止，此时，正拿着花没传出去的那个同学就要给大家表演一个节目。
# 聪明的小赛提出一个有趣的问题：有多少种不同的方法可以使得从小赛手里开始传的花，传了m次以后，又回到小赛手里。对于传递的方法当且仅当这两种方法中，接到花的同学按接球顺序组成的序列是不同的，才视作两种传花的方法不同。比如有3个同学1号、2号、3号，并假设小赛为1号，花传了3次回到小赛手里的方式有1->2->3->1和1->3->2->1，共2种。
# 输入
# 输入共一行，有两个用空格隔开的整数n，m（3<=n<=30，1<=m<=30）
# 样例输入
# 3 3
#
# 输出
# 输出共一行，有一个整数，表示符合题意的方法数
# 样例输出

def solution(dp, n, m):
    # dp[i][j]:i是传递的次数，j是传递的人员编号，次数是指第一次回到j手中
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if i == 1 and j == 1:
                dp[1][1] = 1  # 开始在1号手中经过一次回到1号
            elif i == 1 and j == n - 1:
                dp[1][n - 1] = 1  # 开始在n-1号手中，经过1次回到1号
            elif j + 1 > n:
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][1]
            elif j - 1 < 1:
                dp[i][j] = dp[i - 1][n - 1] + dp[i - 1][j + 1]
            else:
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]


if __name__ == '__main__':
    n, m = 3, 3
    dp = [[0] * 30 for _ in range(30)]
    solution(dp, n, m)
    print(dp[m][1])
