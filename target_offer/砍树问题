# 题目：
# 在你面前有n棵树，而你有两种工具，句子和斧头，他们砍第i棵树的时间分别是ai，bi，一开始你拿的是斧头，
# 而砍第i棵树前交换工具需要花费ci时间，以此砍完这些树的时间最短为多少？

def dfs(a, b, c, n, cur_pos, cur_tool, min_time, cur_time):
    if cur_pos >= n:
        min_time[0] = min(cur_time, min_time[0])
        return

    if cur_time > min_time[0]:
        return

    if cur_tool == 'a':
        dfs(a, b, c, n, cur_pos + 1, cur_tool, min_time, cur_time + a[cur_pos])
        dfs(a, b, c, n, cur_pos + 1, 'b', min_time, cur_time + b[cur_pos] + c[cur_pos])
    else:
        dfs(a, b, c, n, cur_pos + 1, cur_tool, min_time, cur_time + b[cur_pos])
        dfs(a, b, c, n, cur_pos + 1, 'a', min_time, cur_time + a[cur_pos] + c[cur_pos])

def dfs_solution(a, b, c):
    min_time = [float('inf')]
    n = len(a)
    dfs(a, b, c, n, 0, 'b', min_time, 0)
    return min_time[0]


# 这种做法只能拿到29%，为什么？
# 这个问题不是贪心算法，因为当前最优解的状态还和后面的解状态有关系
def solution(a, b, c):
    dp = [0]  # 表示到第i棵树花费的时间
    tool = ['b']  # 表示到第i棵树的使用工具
    leng = len(a)
    for i in range(leng):
        if len(tool[-1]) == 1:
            if tool[-1] == 'a':
                if dp[-1] + a[i] == dp[-1] + c[i] + b[i]:
                    dp.append(dp[-1] + a[i])
                    tool.append(['a', 'b'])
                elif dp[-1] + a[i] < dp[-1] + c[i] + b[i]:
                    dp.append(dp[-1] + a[i])
                    tool.append(['a'])
                else:
                    dp.append(dp[-1] + c[i] + b[i])
                    tool.append(['b'])
            else:
                if dp[-1] + b[i] == dp[-1] + c[i] + a[i]:
                    dp.append(dp[-1] + b[i])
                    tool.append(['a', 'b'])
                elif dp[-1] + b[i] < dp[-1] + c[i] + a[i]:
                    dp.append(dp[-1] + b[i])
                    tool.append(['b'])
                else:
                    dp.append(dp[-1] + c[i] + a[i])
                    tool.append(['a'])
        else:
            if dp[-1] + a[i] == dp[-1] + b[i]:
                dp.append(dp[-1] + a[i])
                tool.append(['a', 'b'])
            elif dp[-1] + a[i] < dp[-1] + b[i]:
                dp.append(dp[-1] + a[i])
                tool.append('a')
            else:
                dp.append(dp[-1] + b[i])
                tool.append('b')
    return dp[-1]


if __name__ == '__main__':
    n = 3
    # a = [20, 10, 90]
    # b = [40, 4, 100]
    # c = [20, 25, 5]

    a = [5, 200, 100]
    b = [10, 190, 200]
    c = [5, 100, 100]

    # n = int(input().strip())
    # a, b, c = [], [], []
    # for each in range(n):
    #     ai, bi, ci = map(int, input().strip().split(' '))
    #     a.append(ai)
    #     b.append(bi)
    #     c.append(ci)
    ans = dfs_solution(a, b, c)
    ans1 = solution(a, b, c)
    print(ans)
    print(ans1)
